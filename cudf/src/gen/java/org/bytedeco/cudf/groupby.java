// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cudf;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.cudf.global.cudf.*;


/**
 * \brief Groups values by keys and computes aggregations on those groups.
 */
@Namespace("cudf::experimental::groupby") @NoOffset @Properties(inherit = org.bytedeco.cudf.presets.cudf.class)
public class groupby extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public groupby(Pointer p) { super(p); }

  
  
  
  
  

  /**
   * \brief Construct a groupby object with the specified {@code keys}
   *
   * If the {@code keys} are already sorted, better performance may be achieved by
   * passing {@code keys_are_sorted == true} and indicating the  ascending/descending
   * order of each column and null order in  {@code column_order} and
   * {@code null_precedence}, respectively.
   *
   * \note This object does *not* maintain the lifetime of {@code keys}. It is the
   * user's responsibility to ensure the {@code groupby} object does not outlive the
   * data viewed by the {@code keys} {@code table_view}.
   *
   * @param keys Table whose rows act as the groupby keys
   * @param ignore_null_keys Indicates whether rows in {@code keys} that contain NULL
   * values should be ignored
   * @param keys_are_sorted Indicates whether rows in {@code keys} are already sorted
   * @param column_order If {@code keys_are_sorted == true}, indicates whether each
   * column is ascending/descending. If empty, assumes all  columns are
   * ascending. Ignored if {@code keys_are_sorted == false}.
   * @param null_precedence If {@code keys_are_sorted == true}, indicates the ordering
   * of null values in each column. Else, ignored. If empty, assumes all columns
   * use {@code null_order::BEFORE}. Ignored if {@code keys_are_sorted == false}.
   */
  public groupby(@Const @ByRef table_view keys, @Cast("bool") boolean ignore_null_keys/*=true*/,
                     @Cast("bool") boolean keys_are_sorted/*=false*/,
                     @StdVector order column_order/*={}*/,
                     @StdVector null_order null_precedence/*={}*/) { super((Pointer)null); allocate(keys, ignore_null_keys, keys_are_sorted, column_order, null_precedence); }
  private native void allocate(@Const @ByRef table_view keys, @Cast("bool") boolean ignore_null_keys/*=true*/,
                     @Cast("bool") boolean keys_are_sorted/*=false*/,
                     @StdVector order column_order/*={}*/,
                     @StdVector null_order null_precedence/*={}*/);
  public groupby(@Const @ByRef table_view keys) { super((Pointer)null); allocate(keys); }
  private native void allocate(@Const @ByRef table_view keys);

  /**
   * \brief Performs grouped aggregations on the specified values.
   *
   * The values to aggregate and the aggregations to perform are specifed in an
   * {@code aggregation_request}. Each request contains a {@code column_view} of values to
   * aggregate and a set of {@code aggregation}s to perform on those elements.
   *
   * For each {@code aggregation} in a request, {@code values[i]} is aggregated with
   * all other {@code values[j]} where rows {@code i} and {@code j} in {@code keys} are equivalent.
   *
   * The {@code size()} of the request column must equal {@code keys.num_rows()}.
   *
   * For every {@code aggregation_request} an {@code aggregation_result} will be returned.
   * The {@code aggregation_result} holds the resulting column(s) for each requested
   * aggregation on the {@code request}s values. The order of the columns in each
   * result is the same order as was specified in the request.
   *
   * The returned {@code table} contains the group labels for each group, i.e., the
   * unique rows from {@code keys}. Element {@code i} across all aggregation results
   * belongs to the group at row {@code i} in the group labels table.
   *
   * The order of the rows in the group labels is arbitrary. Furthermore,
   * successive {@code groupby::aggregate} calls may return results in different
   * orders.
   *
   * @throws cudf::logic_error If {@code requests[i].values.size() !=
   * keys.num_rows()}.
   *
   * Example:
   * <pre>{@code
   * Input:
   * keys:     {1 2 1 3 1}
   *           {1 2 1 4 1}
   * request:
   *   values: {3 1 4 9 2}
   *   aggregations: {{SUM}, {MIN}}
   *
   * result:
   *
   * keys:  {3 1 2}
   *        {4 1 2}
   * values:
   *   SUM: {9 9 1}
   *   MIN: {9 2 1}
   * }</pre>
   *
   * @param requests The set of columns to aggregate and the aggregations to
   * perform
   * @param mr Memory resource used to allocate the returned table and columns
   * @return Pair containing the table with each group's unique key and
   * a vector of aggregation_results for each request in the same order as
   * specified in {@code requests}.
   */
  public native @ByVal std::pair<std::unique_ptr<table>,std::vector<cudf::experimental::groupby::aggregation_result> > aggregate(
        @StdVector aggregation_request requests,
        device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
  public native @ByVal std::pair<std::unique_ptr<table>,std::vector<cudf::experimental::groupby::aggregation_result> > aggregate(
        @StdVector aggregation_request requests);

}

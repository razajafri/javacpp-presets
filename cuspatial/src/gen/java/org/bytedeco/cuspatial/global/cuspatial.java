// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cuspatial.global;

import org.bytedeco.cuspatial.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class cuspatial extends org.bytedeco.cuspatial.presets.cuspatial {
    static { Loader.load(); }

// Targeting ../ColumnPair.java


// Parsed from <cudf/types.h>

// #pragma once

// #include <stdint.h>

// TODO: Update to use fixed width types when CFFI goes away
/** Limits the maximum size of a gdf_column to 2^31-1 */     /*< Storage type for Boolean values. 
                                        char is used to guarantee 8-bit storage. 
                                        zero == false, nonzero == true. */


 /**
 * \brief  These enums indicate the possible data types for a gdf_column
 */
/** enum gdf_dtype */
public static final int
    GDF_invalid = 0,
    GDF_INT8 = 1,
    GDF_INT16 = 2,
    GDF_INT32 = 3,
    GDF_INT64 = 4,
    GDF_FLOAT32 = 5,
    GDF_FLOAT64 = 6,
    /** Boolean stored in 8 bits per Boolean. zero==false, nonzero==true. */
    GDF_BOOL8 = 7,
    /** int32_t days since the UNIX epoch */
    GDF_DATE32 = 8,
    /** int64_t milliseconds since the UNIX epoch */
    GDF_DATE64 = 9,
    /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */
    GDF_TIMESTAMP = 10,
    GDF_CATEGORY = 11,
    GDF_STRING = 12,
    /** Stores indices of an NVCategory in data and in extra col info a reference to the nv_category */
    GDF_STRING_CATEGORY = 13,
    /** additional types should go BEFORE N_GDF_TYPES */
    N_GDF_TYPES = 14;


/**
 * \brief  These are all possible gdf error codes that can be returned from
 * a libgdf function. ANY NEW ERROR CODE MUST ALSO BE ADDED TO {@code gdf_error_get_name}
 * AS WELL
 */
/** enum gdf_error */
public static final int
    GDF_SUCCESS = 0,                
    /** Error occured in a CUDA call */
    GDF_CUDA_ERROR = 1,
    /** The datatype of the gdf_column is unsupported */
    GDF_UNSUPPORTED_DTYPE = 2,
    /** Two columns that should be the same size aren't the same size */
    GDF_COLUMN_SIZE_MISMATCH = 3,
    /** Size of column is larger than the max supported size */
    GDF_COLUMN_SIZE_TOO_BIG = 4,
    /** Input dataset is either null or has size 0 when it shouldn't */
    GDF_DATASET_EMPTY = 5,
    /** gdf_column's validity bitmask is null */
    GDF_VALIDITY_MISSING = 6,
    /** The requested gdf operation does not support validity bitmask handling, and one of the input columns has the valid bits enabled */
    GDF_VALIDITY_UNSUPPORTED = 7,
    /** The arguments passed into the function were invalid */
    GDF_INVALID_API_CALL = 8,
    /** Datatype mismatch between corresponding columns in  left/right tables in the Join function */
    GDF_JOIN_DTYPE_MISMATCH = 9,
    /** Too many columns were passed in for the requested join operation */
    GDF_JOIN_TOO_MANY_COLUMNS = 10,
    /** Type mismatch between columns that should be the same type */
    GDF_DTYPE_MISMATCH = 11,
    /** The method requested to perform an operation was invalid or unsupported (e.g., hash vs. sort) */
    GDF_UNSUPPORTED_METHOD = 12,
    /** Invalid aggregator was specified for a groupby */
    GDF_INVALID_AGGREGATOR = 13,
    /** Invalid hash function was selected */
    GDF_INVALID_HASH_FUNCTION = 14,
    /** Datatype mismatch between columns of input/output in the hash partition function */
    GDF_PARTITION_DTYPE_MISMATCH = 15,
    /** Failed to insert to hash table, likely because its full */
    GDF_HASH_TABLE_INSERT_FAILURE = 16,
    /** The type of join requested is unsupported */
    GDF_UNSUPPORTED_JOIN_TYPE = 17,
    /** C error not related to CUDA */
    GDF_C_ERROR = 18,
    /** error processing sepcified file */
    GDF_FILE_ERROR = 19,
    /** Memory manager error (see memory.h) */
    GDF_MEMORYMANAGER_ERROR = 20,
    /** The requested color used to define an NVTX range is not defined */
    GDF_UNDEFINED_NVTX_COLOR = 21,
    /** The requested name for an NVTX range cannot be nullptr */
    GDF_NULL_NVTX_NAME = 22,
    /** Resolution mismatch between two columns of GDF_TIMESTAMP */
    GDF_TIMESTAMP_RESOLUTION_MISMATCH = 23,
    /** A feature is not implemented */
    GDF_NOTIMPLEMENTED_ERROR = 24,
    /** Two tables that should have the same number of columns have different numbers of columns */
    GDF_TABLES_SIZE_MISMATCH = 25,
    N_GDF_ERRORS = 26;

/** enum gdf_hash_func */
public static final int
    /** Murmur3 hash function */
    GDF_HASH_MURMUR3 = 0,
    /** Identity hash function that simply returns the key to be hashed */
    GDF_HASH_IDENTITY = 1;


/**
 * \brief Defines the unit of time that an algoithm or structure is storing.
 *
 * There are time types in cudf. Those time types can have different resolutions.
 * The types included are nanosecond, microsecond, millisecond, and second.
 */
/** enum gdf_time_unit */
public static final int
  /** The default time unit type. */
  TIME_UNIT_NONE = 0,
  /** Second resolution time unit type */
  TIME_UNIT_s = 1,
  /** Millisecond resolution time unit type */
  TIME_UNIT_ms = 2,
  /** Microsecond resolution time unit type */
  TIME_UNIT_us = 3,
  /** Nanosecond resolution time unit type */
  TIME_UNIT_ns = 4;
// Targeting ../gdf_dtype_extra_info.java


// Targeting ../gdf_data.java


// Targeting ../gdf_scalar.java


// Targeting ../gdf_column.java




/** 
 * \brief  These enums indicate which method is to be used for an operation.
 * For example, it is used to select between the hash-based vs. sort-based implementations
 * of the Join operation.
 */
/** enum gdf_method */
public static final int
  /** Window Variance Indicates that the sort-based implementation of the function will be used */
  GDF_SORT = 0,
  /** Window Variance Indicates that the hash-based implementation of the function will be used */
  GDF_HASH = 1,
  /** Window Variance additional methods should go BEFORE N_GDF_METHODS */
  N_GDF_METHODS = 2;


/** 
 * \brief These enums indicate the supported aggregation operations that can be
 * performed on a set of aggregation columns as part of a GroupBy operation
 */
/** enum gdf_agg_op */
public static final int
  /** Computes the sum of all values in the aggregation column */
  GDF_SUM = 0,
  /** Computes minimum value in the aggregation column */
  GDF_MIN = 1,
  /** Computes maximum value in the aggregation column */
  GDF_MAX = 2,
  /** Computes arithmetic mean of all values in the aggregation column */
  GDF_AVG = 3,
  /** Computes histogram of the occurance of each key in the GroupBy Columns */
  GDF_COUNT = 4,
  /** Counts the number of distinct keys in the GroupBy columns */
  GDF_COUNT_DISTINCT = 5,
  /** Perform a generic aggregation operation detailed in a PTX code generated by {@code numba} */
  GDF_NUMBA_GENERIC_AGG_OPS = 6,
  /** Perform a generic aggregation operation detailed in a CUDA code */
  GDF_CUDA_GENERIC_AGG_OPS = 7,
  /** The total number of aggregation operations. ALL NEW OPERATIONS SHOULD BE ADDED ABOVE THIS LINE */
  N_GDF_AGG_OPS = 8;


/** 
 * \brief  Colors for use with NVTX ranges.
 *
 * These enumerations are the available pre-defined colors for use with
 * user-defined NVTX ranges.
 */
/** enum gdf_color */
public static final int
  GDF_GREEN = 0, 
  GDF_BLUE = 1,
  GDF_YELLOW = 2,
  GDF_PURPLE = 3,
  GDF_CYAN = 4,
  GDF_RED = 5,
  GDF_WHITE = 6,
  GDF_DARK_GREEN = 7,
  GDF_ORANGE = 8,
  /** Add new colors above this line */
  GDF_NUM_COLORS = 9;


/**
 * \brief Options for how nulls are treated in group_by/order_by operations.
 */
/** enum gdf_null_sort_behavior */
public static final int
  /** NULLS are treated as the largest number in comparisons */
  GDF_NULL_AS_LARGEST = 0,
  /** NULLS are treated as the smallest number in comparisons   */
  GDF_NULL_AS_SMALLEST = 1;
// Targeting ../gdf_context.java


// Targeting ../_OpaqueSegmentedRadixsortPlan.java


// Targeting ../gdf_segmented_radixsort_plan_type.java



/** enum order_by_type */
public static final int
  GDF_ORDER_ASC = 0,
  GDF_ORDER_DESC = 1;


// Parsed from <cuspatial/coordinate_transform.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.h>

/**
 * \brief transform 2D longitude/latitude coordinates to x/y coordinates
 *        relative to a camera origin
 *
 * @param cam_lon [in] : longitude of camera origin
 * @param cam_lat [in] : latitude of camera origin
 * @param in_lon [in] : longitude coordinates to transform
 * @param in_lat [in] : latitude coordinates to transform
 *
 * @return a pair of columns storing transformed x/y coordinates
 */
@Namespace("cuspatial") public static native @ByVal ColumnPair lonlat_to_coord(@Const @ByRef gdf_scalar cam_lon,
                                                 @Const @ByRef gdf_scalar cam_lat,
                                                 @Const @ByRef gdf_column in_lon,
                                                 @Const @ByRef gdf_column in_lat);

  // namespace cuspatial


// Parsed from <cuspatial/hausdorff.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once // forward declaration

/**
 * \brief compute Hausdorff distances among all pairs of a set of trajectories
 * 
 * https://en.wikipedia.org/wiki/Hausdorff_distance
 *
 * \p vertex_counts is used to compute the starting offset of each trajectory
 * in \p x and \p y
 * 
 * @param x [in] : x coordinates of the input trajectories
 * @param y [in] : y coordinates of the input trajectories
 * @param vertex_counts [in] : numbers of vertices in each trajectory
 *
 * @return Flattened (1D) column of all-pairs directed Hausdorff distances
 *          among trajectories (i,j)
 * 
 * \note Hausdorff distance is not symmetrical
 */
@Namespace("cuspatial") public static native @ByVal gdf_column directed_hausdorff_distance(@Const @ByRef gdf_column x, @Const @ByRef gdf_column y,
                                       @Const @ByRef gdf_column vertex_counts);

  // namespace cuspatial


// Parsed from <cuspatial/haversine.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once // forward declaration

/**
 * brief Compute Haversine distances among pairs of longitude/latitude locations
 * 
 * @param x [in] 1: longitude coordinates of the starting points
 * @param y [in] 1: latitude coordinates of the starting points
 * @param x [in] 2: longitude coordinates of the ending points
 * @param y [in] 2: latitude coordinates of the ending points
 *
 * @return array of distances in kilometers (km) for all (x1,y1) and (x2,y2)
 *         point pairs
 */
@Namespace("cuspatial") public static native @ByVal gdf_column haversine_distance(@Const @ByRef gdf_column x1, @Const @ByRef gdf_column y1,
                              @Const @ByRef gdf_column x2, @Const @ByRef gdf_column y2);

  // namespace cuspatial


// Parsed from <cuspatial/point_in_polygon.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once // forward declaration

/**
 * \brief Point-in-Polygon (PIP) tests between a column of points and a
 *        column of polygons
 *
 * @param points_x [in] : x coordinates of points
 * @param points_y [in] : y coordinates of points
 * @param poly_fpos [in] : index polygons: prefix sum of number of rings of all
 *            polygons
 * @param poly_rpos [in] : index rings: prefix sum of number of vertices of all
 *            rings
 * @param poly_x [in] : x coordinates of concatenated polygons
 * @param poly_y [in] : y coordinates of concatenated polygons
 *
 * @return gdf_column of type GDF_INT32; the jth bit of the ith element of the
 *          returned GDF_INT32 array is 1 if the ith point is in the jth polygon
 *
 * Note: The # of polygons, i.e., ply_fpos.size cannot exceed 
 * 32 == sizeof(uint32_t)*8. It is possible to use larger integers to
 * accommodate more polygons (e.g., 64/128) in the future. For more polygons,
 * the polygons need to be indexed and the problem essentially becomes a spatial
 * join.
 */
@Namespace("cuspatial") public static native @ByVal gdf_column point_in_polygon_bitmap(@Const @ByRef gdf_column points_x,
                                   @Const @ByRef gdf_column points_y,
                                   @Const @ByRef gdf_column poly_fpos,
                                   @Const @ByRef gdf_column poly_rpos,
                                   @Const @ByRef gdf_column poly_x,
                                   @Const @ByRef gdf_column poly_y);

  // namespace cuspatial


// Parsed from <cuspatial/query.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.h>

/**
 * \brief Find all points (x,y) that fall within a query window
 * (left, bottom, right, top)
 <p>
 * @param left [in] :   x-coordinate of left edge of the query window
 * @param bottom [in] : y-coordinate of bottom of the query window
 * @param right [in] :  x-coordinate of right edge of the query window
 * @param top [in] :    y-coordinate of top of the query window
 * @param x [in] :      x-coordinates of points to be queried
 * @param y [in] :      y-coordinates of points to be queried
 <p>
 * @return pair of gdf_columns of query results of in_x and in_y columns.
 */
 @Namespace("cuspatial") public static native @ByVal ColumnPair spatial_window_points(@Const @ByRef gdf_scalar left,
                                                         @Const @ByRef gdf_scalar bottom,
                                                         @Const @ByRef gdf_scalar right,
                                                         @Const @ByRef gdf_scalar top,
                                                         @Const @ByRef gdf_column x,
                                                         @Const @ByRef gdf_column y);

  // namespace cuspatial


// Parsed from <cuspatial/shapefile_readers.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once // forward declaration

/**
 * \brief read polygon data from an ESRI Shapefile.
 *
 * data type of vertices is fixed to double (GDF_FLOAT64)
 *
 * @param filename [in] : polygon data filename in ESRI Shapefile format
 * @param ply_fpos [out] : index polygons: prefix sum of number of rings of all
 *             polygons
 * @param ply_rpos [out] : index rings: prefix sum of number of vertices of all
 *             rings
 * @param ply_x [out] : x coordinates of concatenated polygons
 * @param ply_y [out] : y coordinates of concatenated polygons
 *
 * \note: x/y can be lon/lat.
**/
@Namespace("cuspatial") public static native void read_polygon_shapefile(@Cast("const char*") BytePointer filename,
                      gdf_column ply_fpos, gdf_column ply_rpos,
                      gdf_column ply_x, gdf_column ply_y);
@Namespace("cuspatial") public static native void read_polygon_shapefile(String filename,
                      gdf_column ply_fpos, gdf_column ply_rpos,
                      gdf_column ply_x, gdf_column ply_y);

// namespace cuspatial


// Parsed from <cuspatial/soa_readers.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once // forward declaration

/**
 * \brief read uint32_t data from file as column
 *
 * @param filename [in] : file to read
 *
 * @return gdf_column storing the uint32_t data
 **/
@Namespace("cuspatial") public static native @ByVal gdf_column read_uint32_soa(@Cast("const char*") BytePointer filename);
@Namespace("cuspatial") public static native @ByVal gdf_column read_uint32_soa(String filename);

/**
 * \brief read timestamp data from file as column
 *
 * @param filename [in] : file to read
 *
 * @return gdf_column storing its_timestamp data
**/
@Namespace("cuspatial") public static native @ByVal gdf_column read_timestamp_soa(@Cast("const char*") BytePointer filename);
@Namespace("cuspatial") public static native @ByVal gdf_column read_timestamp_soa(String filename);

/**
 * \brief read lon/lat from file as two columns; data type is fixed to double (GDF_FLOAT64)
 *
 * @param filename [in] : file name of point data in location_3d layout (lon/lat/alt but alt is omitted)
 *
 * @return gdf_columns storing x and y data
**/
@Namespace("cuspatial") public static native @ByVal ColumnPair read_lonlat_points_soa(@Cast("const char*") BytePointer filename);
@Namespace("cuspatial") public static native @ByVal ColumnPair read_lonlat_points_soa(String filename);

/**
 * \brief read x/y from file as two columns; data type is fixed to double (GDF_FLOAT64)
 * 
 * @param filename [in] : file name of point data in coordinate_2d layout (x/y)
 * 
 * @return gdf_columns storing x and y data
**/
@Namespace("cuspatial") public static native @ByVal ColumnPair read_xy_points_soa(@Cast("const char*") BytePointer filename);
@Namespace("cuspatial") public static native @ByVal ColumnPair read_xy_points_soa(String filename);

/**
 * \brief read polygon data from file in SoA format
 * 
 * data type of vertices is fixed to double (GDF_FLOAT64)
 *
 * @param filename [in] : polygon data filename
 * @param ply_fpos [out] : index polygons: prefix sum of number of rings of all
 *             polygons
 * @param ply_rpos [out] : index rings: prefix sum of number of vertices of all
 *             rings
 * @param ply_x [out] : x coordinates of concatenated polygons
 * @param ply_y [out] : y coordinates of concatenated polygons
 *
 * \note: x/y can be lon/lat.
**/
@Namespace("cuspatial") public static native void read_polygon_soa(@Cast("const char*") BytePointer filename,
                      gdf_column ply_fpos, gdf_column ply_rpos,
                      gdf_column ply_x, gdf_column ply_y);
@Namespace("cuspatial") public static native void read_polygon_soa(String filename,
                      gdf_column ply_fpos, gdf_column ply_rpos,
                      gdf_column ply_x, gdf_column ply_y);

// namespace cuspatial


// Parsed from <cuspatial/trajectory.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.h>

/**
 * \brief derive trajectories from points, timestamps and object ids
 *
 * Points are x/y coordinates relative to an origin. First sorts by object id
 * and timestamp and then groups by id.
 *
 * @param [in/out] x: x coordinates relative to a camera origin
 *                  (before/after sorting)
 * @param [in/out] y: y coordinates relative to a camera origin
 *                   (before/after sorting)
 * @param [in/out] object_id: object (e.g., vehicle) id column (before/after
 *                sorting); upon completion, unique ids become trajectory ids
 * @param [in/out] timestamp: timestamp column (before/after sorting)
 * @param trajectory_id [out] : trajectory id column (see comments on oid)
 * @param length [out] : #of points in the derived trajectories
 * @param offset [out] : position offsets of trajectories used to index x, y,
 *                  object_id and timestamp
 * 
 * @return number of derived trajectories
 */
@Namespace("cuspatial") public static native @Cast("gdf_size_type") int derive_trajectories(@Const @ByRef gdf_column x, @Const @ByRef gdf_column y,
                                  @Const @ByRef gdf_column object_id,
                                  @Const @ByRef gdf_column timestamp,
                                  @ByRef gdf_column trajectory_id,
                                  @ByRef gdf_column length, @ByRef gdf_column offset);


/**
 * \brief Compute the distance and speed of trajectories
 *
 * Trajectories are typically derived from coordinate data using
 * derive_trajectories().
 * 
 * @param x [in] : x coordinates (km) relative to a camera origin and ordered by
 *            (id,timestamp)
 * @param y [in] : y coordinates (km) relative to a camera origin and ordered by
 *            (id,timestamp)
 * @param timestamp [in] : timestamp (ms) column ordered by (id,timestamp)
 * @param length [in] : number of points column ordered by (id,timestamp)
 * @param offset [in] : offsets of trajectories used to index x/y/oid/ts
 *            ordered by (id,timestamp)
 * @param dist [out] : computed distances/lengths of trajectories in meters (m)
 * @param speed [out] : computed speed of trajectories in meters per second (m/s)
 *
 * Note: May output duration in the future (in addition to distance/speed)
 * if needed. Duration can be computed on CPU by fetching begining/ending
 * timestamps of a trajectory in the timestamp array
 */
@Namespace("cuspatial") public static native @ByVal ColumnPair trajectory_distance_and_speed(@Const @ByRef gdf_column x, @Const @ByRef gdf_column y,
                              @Const @ByRef gdf_column timestamp,
                              @Const @ByRef gdf_column length,
                              @Const @ByRef gdf_column offset);


/**
 * \brief compute spatial bounding boxes of trajectories
 *
 * @param x [in] : x coordinates relative to a camera origin and ordered by
 *            (id, timestamp)
 * @param y [in] : y coordinates relative to a camera origin and ordered by
 *            (id, timestamp)
 * @param length [in] : number of points column ordered by (id, timestamp)
 * @param offset [in] : offsets of trajectories used to index x/y ordered by
 *            (id,timestamp)
 * @param bbox_x [out] 1: x coordinates of the lower-left corners of computed
 *             spatial bounding boxes
 * @param bbox_y [out] 1: y coordinates of the lower-left corners of computed
 *             spatial bounding boxes
 * @param bbox_x [out] 2: x coordinates of the upper-right corners of computed
 *             spatial bounding boxes
 * @param bbox_y [out] 2: y coordinates of the upper-right corners of computed
 *             spatial bounding boxes
 *
 * Note: temporal 1D bounding box can be computed similary but it seems that
 * there is no such a need; Similar to the discussion in derive_trajectories,
 * temporal 1D bounding box can be retrieved directly
 */
@Namespace("cuspatial") public static native void trajectory_spatial_bounds(@Const @ByRef gdf_column x, @Const @ByRef gdf_column y,
                               @Const @ByRef gdf_column length,
                               @Const @ByRef gdf_column offset,
                               @ByRef gdf_column bbox_x1, @ByRef gdf_column bbox_y1,
                               @ByRef gdf_column bbox_x2, @ByRef gdf_column bbox_y2);

/**
 * \brief Return a subset of trajectories selected by ID
 <p>
 * @param id [in] : ids of trajectories whose x/y/len/pos data will be kept
 * @param in_x [in] : input x coordinates
 * @param in_y [in] : input y coordinates
 * @param in_id [in] : input ids of points
 * @param in_timestamp [in] : input timestamps of points
 * @param out_x [out] : output x coordinates ordered by (in_id,in_ts)
 * @param out_y [out] : output y coordinates ordered by (in_id,in_ts)
 * @param out_id [out] : output ids ordered by (in_id,in_ts)
 * @param out_timestamp [out] : output timestamp ordered by (in_id,in_ts)
 * 
 * @return number of trajectories returned
 * 
 * \note the output columns are allocated by this function but they must 
 * be deallocated by the caller.
 * 
 * \note this function is likely to be removed in the future since it is 
 * redundant to cuDF functionality
 *
 * \note: the API is useful for integrating with cuDF and serial Python APIs,
 * e.g., query based on trajectory level information using serial Python APIs or
 * cuDF APIs and identify a subset of trajectory IDs. These IDs can then be used
 * to retrieve x/y/len/pos data for futher processing.
 */
@Namespace("cuspatial") public static native @Cast("gdf_size_type") int subset_trajectory_id(@Const @ByRef gdf_column id,
                                   @Const @ByRef gdf_column in_x,
                                   @Const @ByRef gdf_column in_y,
                                   @Const @ByRef gdf_column in_id,
                                   @Const @ByRef gdf_column in_timestamp,
                                   @ByRef gdf_column out_x,
                                   @ByRef gdf_column out_y,
                                   @ByRef gdf_column out_id,
                                   @ByRef gdf_column out_timestamp);

  // namespace cuspatial


// Parsed from <cuspatial/types.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

/**
 * \brief A 3D location: latitude, longitude, altitude
 * 
 * \tparam T the base type for the coordinates
 */

/**
 * \brief A 2D Cartesian location (x, y)
 * 
 * \tparam T the base type for the coordinates
 */
// Targeting ../its_timestamp.java



// namespace cuspatial


}
